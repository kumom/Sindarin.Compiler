/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatesindarin_compiler"]("main",{

/***/ "./src/syntax/parser.ts":
/*!******************************!*\
  !*** ./src/syntax/parser.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ codeRangeComputer),\n/* harmony export */   \"Parser\": () => (/* binding */ Parser),\n/* harmony export */   \"SkippingLexer\": () => (/* binding */ SkippingLexer)\n/* harmony export */ });\n/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nearley */ \"./node_modules/nearley/lib/nearley.js\");\n/* harmony import */ var nearley__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nearley__WEBPACK_IMPORTED_MODULE_0__);\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _codeRangeComputer;\n\nclass SkippingLexer {\n    constructor(lexer) {\n        this.lexer = lexer;\n        this.skip = new Set([\"WS\", \"COMMENT\"]);\n    }\n    next() {\n        do {\n            var token = this.lexer.next();\n            if (!(token != null && this.skip.has(token.type)))\n                return token;\n        } while (true);\n    }\n    reset(chunk, info) {\n        this.lexer.reset(chunk, info);\n    }\n    formatError(token, message) {\n        return this.lexer.formatError(token, message);\n    }\n    save() {\n        return this.lexer.save();\n    }\n    has(name) {\n        return this.lexer.has(name);\n    }\n}\nclass Parser extends (nearley__WEBPACK_IMPORTED_MODULE_0___default().Parser) {\n    constructor(grammar) {\n        super(Parser.prepare(grammar));\n        _codeRangeComputer.set(this, void 0);\n        this.initial = this.save();\n    }\n    static prepare(grammar) {\n        var rigid = grammar.Rigid || [];\n        for (const rule of grammar.ParserRules) {\n            rule.postprocess = rigid.includes(rule.name)\n                ? (data) => this.unfold(data, rule.name)\n                : rule.symbols.length === 1\n                    ? (data) => data[0]\n                    : (data) => Object.assign(data, { type: rule.name });\n        }\n        return grammar;\n    }\n    parse(program) {\n        __classPrivateFieldSet(this, _codeRangeComputer, new codeRangeComputer(program));\n        this.restart();\n        this.feed(program);\n        // For non-ambigious grammar, this is what we what\n        // See: https://nearley.js.org/docs/parser#a-note-on-ambiguity\n        const ast = this.results[0];\n        this.setRange(ast);\n        return this.toTree(ast);\n    }\n    restart() {\n        this.restore(this.initial);\n    }\n    reportError(token) {\n        return this.lexer.formatError(token, \"Syntax error\");\n    }\n    toTree(ast) {\n        if (ast.text) {\n            return {\n                type: ast.type,\n                text: ast.text,\n                children: null,\n                range: ast.range,\n            };\n        }\n        else {\n            let tree = { type: ast.type, range: ast.range, children: [] };\n            for (let i = 0; i < ast.length; i++)\n                tree.children.push(this.toTree(ast[i]));\n            return tree;\n        }\n    }\n    setRange(ast) {\n        if (ast.text) {\n            const start = __classPrivateFieldGet(this, _codeRangeComputer).getNumberAndColumnFromPos(ast.offset);\n            const end = __classPrivateFieldGet(this, _codeRangeComputer).getNumberAndColumnFromPos(ast.offset + ast.text.length);\n            ast.range = {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column,\n            };\n        }\n        else {\n            for (let i = 0; i < ast.length; i++)\n                this.setRange(ast[i]);\n            const firstChild = ast[0], lastChild = ast[ast.length - 1];\n            ast.range = {\n                startLineNumber: firstChild.range.startLineNumber,\n                startColumn: firstChild.range.startColumn,\n                endLineNumber: lastChild.range.endLineNumber,\n                endColumn: lastChild.range.endColumn,\n            };\n        }\n    }\n    static unfold(data, type) {\n        function* iter() {\n            for (const d of data) {\n                if (d.type === type)\n                    yield* d;\n                else\n                    yield d;\n            }\n        }\n        return Object.assign([...iter()], { type });\n    }\n}\n_codeRangeComputer = new WeakMap();\n// Code below is copied from https://github.com/dsherret/ts-ast-viewer/blob/master/src/utils/LineAndColumnComputer.ts\nclass ArrayUtils {\n    static from(iterator) {\n        const array = [];\n        while (true) {\n            const next = iterator.next();\n            if (next.done) {\n                return array;\n            }\n            array.push(next.value);\n        }\n    }\n    static binarySearch(items, compareTo) {\n        let top = items.length - 1;\n        let bottom = 0;\n        while (bottom <= top) {\n            const mid = Math.floor((top + bottom) / 2);\n            const comparisonResult = compareTo(items[mid]);\n            if (comparisonResult === 0) {\n                return mid;\n            }\n            else if (comparisonResult < 0) {\n                top = mid - 1;\n            }\n            else {\n                bottom = mid + 1;\n            }\n        }\n        return -1;\n    }\n    constructor() { }\n}\nfunction createLineNumberAndColumns(text) {\n    const lineInfos = [];\n    let lastPos = 0;\n    for (let i = 0; i < text.length; i++) {\n        if (text[i] === \"\\n\") {\n            pushLineInfo(i);\n        }\n    }\n    pushLineInfo(text.length);\n    return lineInfos;\n    function pushLineInfo(pos) {\n        lineInfos.push({\n            pos: lastPos,\n            length: pos - lastPos,\n            number: lineInfos.length + 1,\n        });\n        lastPos = pos + 1;\n    }\n}\n/** An efficient way to compute the line and column of a position in a string. */\nclass codeRangeComputer {\n    constructor(text) {\n        this.text = text;\n        this.lineInfos = createLineNumberAndColumns(text);\n    }\n    getNumberAndColumnFromPos(pos) {\n        if (pos < 0) {\n            return { lineNumber: 1, column: 1 };\n        }\n        const index = ArrayUtils.binarySearch(this.lineInfos, (info) => {\n            if (pos < info.pos) {\n                return -1;\n            }\n            if (pos >= info.pos && pos < info.pos + info.length + 1) {\n                // `+ 1` is for newline char\n                return 0;\n            }\n            return 1;\n        });\n        const lineInfo = index >= 0\n            ? this.lineInfos[index]\n            : this.lineInfos[this.lineInfos.length - 1];\n        if (lineInfo == null) {\n            return { lineNumber: 1, column: 1 };\n        }\n        return {\n            lineNumber: lineInfo.number,\n            column: Math.min(pos - lineInfo.pos + 1, lineInfo.length + 1),\n        };\n    }\n    getPosFromLineAndColumn(line, column) {\n        if (this.lineInfos.length === 0 || line < 1) {\n            return 0;\n        }\n        const lineInfo = this.lineInfos[line - 1];\n        if (lineInfo == null) {\n            const lastLineInfo = this.lineInfos[this.lineInfos.length - 1];\n            return lastLineInfo.pos + lastLineInfo.length;\n        }\n        return lineInfo.pos + Math.min(lineInfo.length, column - 1);\n    }\n}\n\n\n\n//# sourceURL=webpack://sindarin.compiler/./src/syntax/parser.ts?");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ "use strict";
/******/ 
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("bd31108baf786a85da91")
/******/ })();
/******/ 
/******/ }
);