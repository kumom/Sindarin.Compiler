/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatesindarin_compiler"]("main",{

/***/ "./src/analysis/hypergraph.ts":
/*!************************************!*\
  !*** ./src/analysis/hypergraph.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Hypergraph\": () => (/* binding */ Hypergraph),\n/* harmony export */   \"HypergraphView\": () => (/* binding */ HypergraphView)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v1.js\");\n/* harmony import */ var vis_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vis-network */ \"./node_modules/vis-network/peer/umd/vis-network.min.js\");\n/* harmony import */ var vis_network__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vis_network__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vis_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vis-data */ \"./node_modules/vis-data/peer/umd/vis-data.min.js\");\n/* harmony import */ var vis_data__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vis_data__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nclass Hypergraph {\n    constructor() {\n        this.vertices = new Map();\n        this.edges = [];\n        this._max = 0;\n    }\n    get nodes() {\n        var v = new Set();\n        for (let e of this.edges)\n            for (let u of e.incident)\n                v.add(u);\n        return v;\n    }\n    add(edges) {\n        var vmap = new Map(), get = (u) => {\n            if (typeof u === \"number\") {\n                if (u > 0)\n                    return this._get(u);\n                else {\n                    var v = vmap.get(u);\n                    if (!v) {\n                        v = this._fresh();\n                        vmap.set(u, v);\n                    }\n                    return v;\n                }\n            }\n            else {\n                if (!this.vertices.get(u.id))\n                    this.vertices.set(u.id, u);\n                return u;\n            }\n        };\n        for (let e of edges) {\n            for (let u of [e.target, ...e.sources])\n                if (typeof u === \"number\")\n                    this._max = Math.max(this._max, u);\n        }\n        var added = edges.map((ed) => {\n            var e = new Hypergraph.Edge(ed.label, ed.sources.map(get), get(ed.target));\n            e.sources.forEach((u) => u.outgoing.push(e));\n            e.target.incoming.push(e);\n            return e;\n        });\n        this.edges.push(...added);\n        return added;\n    }\n    remove(edges) {\n        for (let e of edges) {\n            e.target.incoming = e.target.incoming.filter((ue) => ue !== e);\n            for (let u of e.sources) {\n                u.outgoing = u.outgoing.filter((ue) => ue !== e);\n            }\n        }\n        this.edges = this.edges.filter((e) => !edges.includes(e));\n    }\n    merge(vertices) {\n        var rep = vertices[0];\n        for (let u of vertices.slice(1)) {\n            for (let e of u.incoming) {\n                e.target = rep;\n                rep.incoming.push(e);\n            }\n            for (let e of u.outgoing) {\n                e.sources = e.sources.map((v) => (u === v ? rep : v));\n                rep.outgoing.push(e);\n            }\n            this.vertices.delete(u.id);\n        }\n    }\n    fromAst(ast) {\n        var self = this, c = this._max;\n        function aux(ast) {\n            var root = ++c, u = self._get(root);\n            if (Array.isArray(ast)) {\n                var subs = ast.map(aux);\n                self.add([{ label: ast.type || \"\", sources: subs, target: root }]);\n            }\n            else {\n                u.label = ast.text;\n            }\n            u.data = { ast }; /** @oops */\n            return root;\n        }\n        aux(ast);\n        this._max = c;\n        return this;\n    }\n    _get(id) {\n        var v = this.vertices.get(id);\n        if (!v) {\n            v = new Hypergraph.Vertex(id);\n            this.vertices.set(id, v);\n        }\n        return v;\n    }\n    _fresh() {\n        var u = new Hypergraph.Vertex(++this._max);\n        this.vertices.set(u.id, u);\n        return u;\n    }\n    toVis(edgeNodeProfile = null) {\n        var nodes = new vis_data__WEBPACK_IMPORTED_MODULE_1__.DataSet([...this.vertices.values()].map((u) => {\n            return {\n                id: u.id,\n                label: u.label || `${u.id}`,\n                shape: \"box\",\n                ...(u.label ? LIT : {}),\n            };\n        }));\n        // Collect edges\n        var edges = new vis_data__WEBPACK_IMPORTED_MODULE_1__.DataSet([]);\n        for (let e of this.edges) {\n            var ve = e.toVis(edgeNodeProfile);\n            nodes.add(ve.nodes);\n            edges.add(ve.edges);\n        }\n        return new HypergraphView(this, {\n            nodes: nodes,\n            edges: edges,\n        });\n    }\n}\n(function (Hypergraph) {\n    class Vertex {\n        constructor(id) {\n            this.incoming = [];\n            this.outgoing = [];\n            this.id = id;\n        }\n    }\n    Hypergraph.Vertex = Vertex;\n    class Edge {\n        constructor(label, sources, target) {\n            this.label = label;\n            this.sources = sources;\n            this.target = target;\n        }\n        get incident() {\n            return [this.target, ...this.sources];\n        }\n        toVis(edgeNodeProfile = null) {\n            edgeNodeProfile = edgeNodeProfile || NUCLEUS;\n            var nucleus = (0,uuid__WEBPACK_IMPORTED_MODULE_2__.default)(), nodes = [\n                { id: nucleus, label: this.label, ...edgeNodeProfile },\n            ], edges = [\n                // @ts-ignore\n                { from: nucleus, to: this.target.id, ...TO },\n                // @ts-ignore\n                ...this.sources.map((v) => ({ from: v.id, to: nucleus, ...FROM })),\n            ];\n            return { nodes, edges };\n        }\n    }\n    Hypergraph.Edge = Edge;\n})(Hypergraph || (Hypergraph = {}));\nconst NUCLEUS = {\n    shape: \"box\",\n    color: \"#cca\",\n    shapeProperties: { borderRadius: 99 },\n}, TO = {\n    arrows: { to: { enabled: true, scaleFactor: 0.5 } },\n    color: \"#997\",\n    length: 1,\n}, FROM = {\n    arrows: { middle: { enabled: true, scaleFactor: 0.5 } },\n    color: \"#997\",\n    length: 1,\n}, LIT = { color: \"#9d9\", shapeProperties: { borderRadius: 0 } }, FAINT = {\n    color: {\n        background: \"#ddd\",\n        border: \"#bbb\",\n        highlight: { background: \"#ddd\", border: \"#bbb\" },\n    },\n    font: { color: \"#ccc\" },\n    opacity: 0.5,\n}, HIE = {\n    hierarchical: {\n        direction: \"DU\",\n        sortMethod: \"directed\",\n        levelSeparation: 75,\n    },\n}, PHY = {\n    physics: {\n        enabled: true,\n        solver: \"repulsion\",\n        minVelocity: 4,\n        timestep: 1,\n        hierarchicalRepulsion: {\n            nodeDistance: 50,\n            avoidOverlap: 1,\n        },\n    },\n};\nclass HypergraphView {\n    constructor(peg, data) {\n        this.options = {\n            layout: {\n                improvedLayout: false,\n                ...HIE,\n            },\n            interaction: {\n                zoomSpeed: 0.3,\n            },\n            ...PHY,\n        };\n        this.peg = peg;\n        this.data = data;\n        if (this.data.options)\n            this.options = this.data.options;\n    }\n    render(on) {\n        this.network = new vis_network__WEBPACK_IMPORTED_MODULE_0__.Network(on, this.data, this.options);\n        // TODO: off\n        this.network.on(\"selectNode\", this._onNodeSelected.bind(this));\n        this.network.on(\"deselectNode\", this._onNodeDeselected.bind(this));\n        return this;\n    }\n    nail() {\n        this.network.storePositions();\n        this.network.setOptions({ layout: { hierarchical: { enabled: false } } });\n        this.data.nodes.update(this.data.nodes\n            .getIds()\n            .map((id) => ({ id, fixed: true /*physics: false*/ })));\n        this.data.edges.update(this.data.edges.getIds().map((id) => ({ id, physics: false })));\n        this.network.setOptions({ physics: { solver: \"repulsion\" } });\n    }\n    fade() {\n        this.data.nodes.update(this.data.nodes.getIds().map((id) => ({ id, ...FAINT })));\n        this.data.edges.update(this.data.edges\n            .getIds()\n            .map((id) => ({ id, color: \"#ccc\", smooth: false })));\n        this.postprocess();\n    }\n    merge(that) {\n        that.data.nodes.forEach((u) => {\n            if (!this.data.nodes.get(u.id))\n                this.data.nodes.add(u);\n        });\n        that.data.edges.forEach((e) => {\n            this.data.edges.add(e);\n        });\n    }\n    untangle() {\n        for (let row of this.iterLevels())\n            this.sortHorizontally(row);\n    }\n    *iterLevels() {\n        var yvisited = new Set();\n        for (let u of Object.values(this._nodes)) {\n            if (!yvisited.has(u.y)) {\n                yvisited.add(u.y);\n                yield this.getLevel(u.id);\n            }\n        }\n    }\n    selectLevel(node) {\n        this.network.selectNodes(this.getLevel(node).map((u) => u.id));\n    }\n    getLevel(node) {\n        if (!node) {\n            node = this.network.getSelectedNodes()[0];\n            if (!node)\n                return;\n        }\n        var pos = this.network.getPosition(node);\n        return Object.values(this._nodes).filter((u) => u.y == pos.y);\n    }\n    sortHorizontally(nodes) {\n        if (!nodes) {\n            var _m = this._nodes;\n            nodes = this.network.getSelectedNodes().map((id) => _m[id]);\n        }\n        var posx = nodes.map((u) => u.x).sort((x1, x2) => x1 - x2);\n        for (let i in nodes) {\n            this.network.moveNode(nodes[i].id, posx[i], nodes[i].y);\n        }\n    }\n    postprocess() {\n        for (let e of Object.values(this._edges))\n            this._shortenEdge(e);\n        this.network.redraw();\n    }\n    get _nodes() {\n        /** @oops */\n        return this.network.body.nodes;\n    }\n    get _edges() {\n        /** @oops */\n        return this.network.body.edges;\n    }\n    _drawingContext() {\n        var r = this.network.view, ctx = r.canvas.getContext();\n        ctx.translate(r.body.view.translation.x, r.body.view.translation.y);\n        ctx.scale(r.body.view.scale, r.body.view.scale);\n        return ctx;\n    }\n    /**\n     * Makes edge start and end at node borders, instead of Vis.js's\n     * default, which is their centers.\n     * @param e renderer edge\n     * @oops this is using internal APIs and monkey-patching because the\n     *   EdgeType class hierarchy is not exposed.\n     */\n    _shortenEdge(e) {\n        var shape = e.edgeType; /** @oops internal API */\n        if (shape.constructor.name === \"StraightEdge\") {\n            shape._drawLine = function (ctx, val) {\n                this.fromPoint = this.getArrowData(ctx, \"from\", null, false, false, val).point;\n                this.toPoint = this.getArrowData(ctx, \"to\", null, false, false, val).point;\n                this.constructor.prototype._drawLine.call(this, ctx, val);\n            };\n        }\n        /** @todo not handling non-straight edges atm */\n    }\n    overlay(peg, disableBase = true, edgeNodeProfile = null) {\n        const overlayView = peg.toVis(edgeNodeProfile);\n        this.nail();\n        if (disableBase) {\n            this.fade();\n        }\n        setTimeout(() => this.merge(overlayView), 1);\n    }\n    _onNodeSelected({ nodes }) {\n        // if (nodes.length !== 1) {\n        //     throw new Error(\"Umm... not yet :-)\")\n        // }\n        //\n        // const vertices = nodes.map(parseInt).map(id => this.peg.vertices.get(id));\n        // const vertex = vertices[0];\n        //\n        // const scopeResolutionPeg = new Hypergraph();\n        // scopeResolutionPeg._max = this.peg._max;\n        //\n        // if (!resolveLexicalScope(this.peg, scopeResolutionPeg, vertex)) {\n        //     return;\n        // }\n        //\n        // this.overlay(scopeResolutionPeg, false, {shape: 'box', color: '#ca2340', shapeProperties: {borderRadius: 99}});\n    }\n    _onNodeDeselected({ previousSelection }) { }\n}\n\n\n\n//# sourceURL=webpack://sindarin.compiler/./src/analysis/hypergraph.ts?");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ "use strict";
/******/ 
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("12cc8388f31b195ecc02")
/******/ })();
/******/ 
/******/ }
);